# initially generated by Claude Code

import requests
import time
from math import radians, sin, cos, sqrt, atan2
from datetime import datetime

# Your home coordinates (Frankfurt a.M., Germany)
HOME_LAT = 50.1137
HOME_LON = 8.6796
RADIUS_KM = 25  # Search radius in kilometers

def haversine_distance(lat1, lon1, lat2, lon2):
    """
    Calculate the great circle distance between two points 
    on the earth (specified in decimal degrees)
    Returns distance in kilometers
    """
    R = 6371  # Radius of the earth in km
    
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    distance = R * c
    
    return distance

def get_bounding_box(lat, lon, radius_km):
    """
    Calculate bounding box coordinates for API query
    Returns (lat_min, lon_min, lat_max, lon_max)
    """
    # Rough conversion: 1 degree latitude ‚âà 111 km
    # 1 degree longitude varies by latitude
    lat_delta = radius_km / 111.0
    lon_delta = radius_km / (111.0 * cos(radians(lat)))
    
    return (
        lat - lat_delta,  # lamin
        lon - lon_delta,  # lomin
        lat + lat_delta,  # lamax
        lon + lon_delta   # lomax
    )

def fetch_flights():
    """
    Fetch flights from OpenSky Network API
    """
    # Get bounding box
    lamin, lomin, lamax, lomax = get_bounding_box(HOME_LAT, HOME_LON, RADIUS_KM)
    
    # OpenSky Network API endpoint
    url = f"https://opensky-network.org/api/states/all?lamin={lamin}&lomin={lomin}&lamax={lamax}&lomax={lomax}"
    
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if data and 'states' in data and data['states']:
            return data['states']
        else:
            return []
    
    except requests.exceptions.RequestException as e:
        print(f"Error fetching data: {e}")
        return []

def display_flight_info(state):
    """
    Display information about a single flight
    State vector format from OpenSky API:
    [0] icao24, [1] callsign, [2] origin_country, [5] longitude, [6] latitude,
    [7] baro_altitude, [9] velocity, [10] true_track, [13] geo_altitude
    """
    icao24 = state[0]
    callsign = state[1].strip() if state[1] else "N/A"
    origin = state[2]
    lon = state[5]
    lat = state[6]
    altitude = state[7] if state[7] else state[13]  # baro_altitude or geo_altitude
    velocity = state[9]
    heading = state[10]
    
    # Calculate distance from home
    if lat and lon:
        distance = haversine_distance(HOME_LAT, HOME_LON, lat, lon)
    else:
        distance = None
    
    print(f"\n{'='*60}")
    print(f"Callsign:     {callsign}")
    print(f"ICAO24:       {icao24}")
    print(f"Origin:       {origin}")
    
    if lat and lon:
        print(f"Position:     {lat:.4f}¬∞, {lon:.4f}¬∞")
    if distance:
        print(f"Distance:     {distance:.2f} km from home")
    if altitude:
        print(f"Altitude:     {altitude:.0f} m ({altitude * 3.28084:.0f} ft)")
    if velocity:
        print(f"Speed:        {velocity:.1f} m/s ({velocity * 3.6:.1f} km/h)")
    if heading:
        print(f"Heading:      {heading:.1f}¬∞")

def main():
    """
    Main function to continuously monitor flights
    """
    print(f"üõ©Ô∏è  Flight Tracker for Neustadt an der Weinstra√üe")
    print(f"üìç Home: {HOME_LAT}¬∞N, {HOME_LON}¬∞E")
    print(f"üì° Monitoring radius: {RADIUS_KM} km")
    print(f"{'='*60}\n")
    print("Press Ctrl+C to stop\n")
    
    try:
        while True:
            print(f"\n[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Fetching flights...")
            
            flights = fetch_flights()
            
            if flights:
                # Filter flights within radius and sort by distance
                nearby_flights = []
                
                for state in flights:
                    lat = state[6]
                    lon = state[5]
                    
                    if lat and lon:
                        distance = haversine_distance(HOME_LAT, HOME_LON, lat, lon)
                        if distance <= RADIUS_KM:
                            nearby_flights.append((distance, state))
                
                # Sort by distance (closest first)
                nearby_flights.sort(key=lambda x: x[0])
                
                print(f"Found {len(nearby_flights)} flight(s) within {RADIUS_KM} km")
                
                for distance, state in nearby_flights:
                    display_flight_info(state)
            else:
                print("No flights detected in the area")
            
            print(f"\n{'='*60}")
            print("Waiting 10 seconds before next update...")
            print("(OpenSky Network recommends max 1 request per 10 seconds for anonymous users)")
            time.sleep(10)
    
    except KeyboardInterrupt:
        print("\n\nüëã Flight tracking stopped by user")
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}")

if __name__ == "__main__":
    main()